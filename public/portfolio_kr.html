<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width">
		<title>포트폴리오</title>
		<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
		<link rel="stylesheet" href="style.css">
	</head>
	<body>
		<div class="bg"> 
			<nav class="navbar navbar-expand-lg navbar-light">
  <div class="container-fluid">
    <a class="navbar-brand" href="https://simoncreek.xyz">Simon Creek</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto mb-2 mb-lg-0">
        <li class="nav-item">
          <a class="nav-link" href="https://blog.simoncreek.xyz" style="background-color: #00000000;">Blog</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/simhyeon" style="background-color: #00000000;">Github</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://simoncreek.xyz/aboutme.html" style="background-color: #00000000;">About Me</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://simoncreek.xyz/portfolio_kr.html" style="background-color: #00000000;">포트폴리오</a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://gd.simoncreek.xyz" style="background-color: #00000000;">역기획 저장소</a>
        </li>
      </ul>
    </div>
  </div>
</nav>
			<div class="container">
				<h1 id="ppfTitle">게임 시스템 디자이너 그리고 데스옵스 엔지니어</h1>
				<hr>
				<br>
				<p>목차</p>
				<ol>
					<li><a href="#systemDesign" target="_self">시스템 디자인</a></li>
					<ul>
						<li><a href="#sevenKnights2" target="_self">세븐나이츠2 레이드</a></li>
						<li><a href="#vindictus" target="_self">마비노기 영웅전 강화</a></li>
						<li><a href="#granSaga" target="_self">그랑사가 왕국 퀘스트</a></li>
						<li><a href="#v4Game" target="_self">V4 마석</a></li>
						<li><a href="#lostArk" target="_self">로스트아크 진형</a></li>
					</ul>
					<li><a href="#desops" target="_self">데스옵스 엔지니어링</a></li>
					<ul>
						<li><a href="#gesign" target="_self">Gesign: 파일 추적 문서 편집기</a></li>
						<li><a href="#gdmarp" target="_self">Gdmarp: 동적 문서 생성 스크립트</a></li>
					</ul>
					<li><a href="#gameDevelopment" target="_self">게임 개발</a></li>
					<ul>
						<li><a href="#unityCardGame" target="_self">유니티 온라인 카드 게임, 리들러</a></li>
						<li><a href="#tetrisGame" target="_self">테트리스 게임, 데이터 지향 프로그래밍</a></li>
						<li><a href="#gameServer" target="_self">게임 서버 개발</a></li>
					</ul>
				</ol>
				<br></br>
				<h3 id="systemDesign">시스템 디자인</h3>
				<hr>
				<p><a href="https://gd.simoncreek.xyz" target="_blank">모든 기획서 저장소</a></p>
				<br/>
				<p>
				게임의 시스템이 어떻게 기획되는지를 이해하는 가장 빠른 방법 중
				하나는 상용 게임의 시스템을 기반으로 역기획을 해보는 것입니다.
				그에 따라 직접 만든 문서 작업 자동화 스크립트를 사용하여 여러
				게임의 시스템 역기획 문서를 작성해 보았습니다. 
				</p>
				<br>
				<h4 id="sevenKnights2"><a href="https://gd.simoncreek.xyz/simoncreek/sevenknights2_raid/src/branch/master/%EC%84%B8%EB%B8%90%EB%82%98%EC%9D%B4%EC%B8%A02-%EB%A0%88%EC%9D%B4%EB%93%9C.pdf" target="_blank">세븐나이츠2 레이드 시스템</a></h4>
				<p>
				기본적인 기획 구성은 <strong>시스템의 진입</strong>, 즉 어떻게
				플레이어가 시스템을 발견하고 시스템을 사용하게 되는 것인지
				그리고 <strong>시스템의 구성(내용)</strong> 그리고
				<strong>시스템의 보상</strong>으로 이루어집니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/sk2_start.png" alt="sk2 start"/>
					<figcaption>시스템 진입</figcaption>
				</figure>
				<br>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/sk2_process.png" alt="sk2 process"/>
					<figcaption>시스템 구성</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/sk2_reward.png" alt="sk2 reward"/>
					<figcaption>시스템 보상</figcaption>
				</figure>
				<br>
				<p>
				그리고 시스템의 UI의 변화, 적용 방식이 어떻게 되는지를 설명하는
				<strong>UI 구성</strong>, 마지막으로 UI의 대략적인 구조도
				부분인 <strong>UI 상세</strong>가 위치합니다.
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/sk2_ui.png" alt="sk2 ui"/>
					<figcaption>UI 구성</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/sk2_ui_spec.png" alt="sk2 ui spec"/>
					<figcaption>UI 상세</figcaption>
				</figure>
				</p>
				<h4 id="vindictus"><a href="https://gd.simoncreek.xyz/simoncreek/vindictus_enhancement/src/branch/master/%EB%A7%88%EC%98%81%EC%A0%84%EA%B0%95%ED%99%94.pdf" target="_blank">마비노기 영웅전 강화 시스템</a></h4>
				<br>
				<p>
				한 파트가 너무 길어질 경우에는 여러 장의 슬라이드로 나눠 가독성을 높입니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/vin_process_1.png" alt="vin process 1"/>
					<figcaption>시스템 구성 1</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/vin_process_2.png" alt="vin process 2"/>
					<figcaption>시스템 구성 2</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/vin_process_3.png" alt="vin process 3"/>
					<figcaption>시스템 구성 3</figcaption>
				</figure>
				<br>
				<p>
				플로우 차트를 첨부하여 시스템의 진행 구조를 더욱 명확하게 할 수 있습니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/vin_flowchart.png" alt="vindictus flowchart"/>
					<figcaption>시스템 구조 플로우차트</figcaption>
				</figure>
				<h4 id="granSaga"><a href="https://gd.simoncreek.xyz/simoncreek/gransaga_kingdom/src/branch/master/%EA%B7%B8%EB%9E%91%EC%82%AC%EA%B0%80_%EC%99%95%EA%B5%AD%ED%80%98%EC%8A%A4%ED%8A%B8_%EC%97%AD%EA%B8%B0%ED%9A%8D.pdf" target="_blank">그랑사가 왕국 퀘스트 시스템</a></h4>
				<br>
				<p>
				서로 연관된 UI가 있을 경우에는 직접적으로 연결되지 않더라도
				설명의 용이함을 위해서 UI 설명을 붙일 수도 있습니다. 또한 UI를
				설명하기 위해서 화면의 모든 것을 보여줄 필요는 없고 설명의
				중점이 되는 창을 기준으로 하여 직관성을 높입니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/gran_ui.png" alt="Ui"/>
					<figcaption>UI 구성</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/gran_ui_spec.png" alt="ui spec"/>
					<figcaption>UI 상세</figcaption>
				</figure>
				<h4 id="v4Game"><a href="https://gd.simoncreek.xyz/simoncreek/v4_incuse/src/branch/master/V4_%EB%A7%88%EC%84%9D%EA%B0%81%EC%9D%B8_%EC%8B%9C%EC%8A%A4%ED%85%9C_%EC%97%AD%EA%B8%B0%ED%9A%8D.pdf" target="_blank">V4 마석 시스템</a></h4>
				<br>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/v4_concept.png" alt="concept"/>
					<figcaption>시스템 개요</figcaption>
				</figure>
				<p>
				시스템 개요만으로 시스템의 목적을 명확히 설명하기 어렵다면
				구체적인 기대효과를 명시하여 기획의 방향성을 직접 설명하여
				독자들의 이해를 돕습니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/v4_expectation.png" alt="expectation"/>
					<figcaption>시스템 기대효과</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/v4_ui.png" alt="ui"/>
					<figcaption>UI 구성</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/v4_ui_spec.png" alt="ui spec"/>
					<figcaption>UI 상세</figcaption>
				</figure>
				<br>
				<p>
				그리고 로스트아크의 경우는 직접 시스템을 새롭게 기획해 보기도 했습니다.
				</p>
				<br>
				<h4 id="lostArk"><a href="https://gd.simoncreek.xyz/simoncreek/lostark_formation/src/branch/master/%EB%A1%9C%EC%8A%A4%ED%8A%B8%EC%95%84%ED%81%AC_%EC%A7%84%ED%98%95%EC%8B%9C%EC%8A%A4%ED%85%9C_%EA%B8%B0%ED%9A%8D.pdf" target="_blank">로스트 아크 진형 시스템 기획</a></h4>
				<br/>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/loastark_concept.png" alt="concept"/>
					<figcaption>시스템 개요</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/lostark_expectation.png" alt="expectation"/>
					<figcaption>시스템 기대효과</figcaption>
				</figure>
				<br>
				<p>
				시스템이 여러 하위 개념으로 구성된다면 각각의 개요를 작성하여
				개념과의 구분과 관계를 명확히 합니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/loastark_stance_concept.png" alt="stance"/>
					<figcaption>시스템 하위 개념 개요 1</figcaption>
				</figure>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/lostark_formation_concept.png" alt="formation"/>
					<figcaption>시스템 하위 개념 개요 2</figcaption>
				</figure>
				<br>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/lostark_ui.png" alt="ui"/>
					<figcaption>UI 구성</figcaption>
				</figure>
				<br>
				<p>
				기존의 시스템과 유사하지 않은 새로운 시스템의 경우는 시스템
				기획에서 간단하게 예시를 들어 독자의 이해를 높입니다. 
				</p>
				<figure>
					<img style="width: 80%; display:block; margin:auto;"src="./img/lostark_example.png" alt="example"/>
					<figcaption>콘텐츠 예시</figcaption>
				</figure>
				<h3 id="desops">데스옵스 엔지니어</h3>
				<hr/>
				<p>
				<strong>데스옵스(Desops)</strong>란 design + operation의
				합성어로서 <strong>디자인(기획)과 오퍼레이션을
				연결</strong>하는 역할을 말합니다. 다른 말로 하면 "<i>게임
				디자인이 다른 개발 직군과 다양하게 상호작용하며 피드백을 수용하고
				최종 디자인 결과를 배포, 전달하는 일련의 과정(오퍼레이션,
				operation)</i>"들의 효율을 높이고 자동화하여 원격 근무나 주 52시간제
				등의 <strong>다양한 근무 형태에 적응</strong>할 수 있고 어자일(Agile)
				친화적인 디자인 프로세스를 형성하여 <strong>게임 개발을 체계화하고 개발
				기간을 예측 가능</strong>하도록 설계하는 역할입니다. 
				</p>
				<p>
				그러므로 데스옵스는 게임 디자인(기획)이 다음과 같은 특징을 가지도록 합니다. 
				</p>
				<ul>
					<li>기획의 내용이 체계적으로 연결되어 있고 세분화(Modular)되어 있을 것</li>
					<li>동일한 작업의 반복을 자동화하고 디자이너가 오로지 기획의 내용에만 집중할 수 있을 것</li>
					<li>여러 디자이너들이 완성한 작업물이 시공간의 제약이나 충돌 없이 결합(Integrate)될 것</li>
					<li>기획 내용의 변화가 가져올 영향을 다른 개발 직군이 직접 구현하기 이전에 예측 가능할 것</li>
					<li>다른 직군의 피드백을 수용하는 과정에서 의도하지 않은 오류가 발생하지 않도록 하는 것</li>
				</ul>
				<p>
				이를 위해서 저는 다음과 같은 프로젝트들을 만들어 왔습니다. 
				</p>
				<br>
				<h4 id="gesign"><strong>Gesign 에디터</strong></h4>
				<a href="https://github.com/simhyeon/gesign" target="_blank">Github 링크</a>
				<figure id="gesign_demo">
					<img src="./img/gesign_demo.png" alt="Gesign demo image"/>
					<figcaption>Gesign 데모: 레벨 매니저가 레벨보다 오래되었기 때문에 레벨 매니저는 업데이트가 필요한 상황.</figcaption>
				</figure>
				<br>
				<p>Gesign Editor란 일렉트론(Electron)과 웹기술을 바탕으로 작성된 <strong>게임 기획 문서 에디터</strong>입니다.</p>
				<p>
				Gesign은 기본적으로 <strong>마크다운(Markdown)</strong>이라고
				하는 텍스트 형식을 사용합니다. 그 이유는 docx 등의 xml 파일이나
				이진(Binary) 파일들은 불필요한 정보가 너무 많거나 다른 형태로
				변형하기 어렵기 때문입니다. 기획 문서는 손쉽게 작성할 수 있어야
				하고 자동화로 반복작업은 줄어야 합니다. 
				</p>
				<p>
				Gesign의 핵심 기능은 <strong>참조 파일 추적</strong>에
				있습니다. 게임의 시스템이나 콘텐츠는 그 내용이 제대로 작동하기
				위해서 다른 시스템이 특정 방식으로 작동할 것으로 기대합니다.
				그러므로 문서 A가 참조하는 다른 문서 B의 내용이 변경되었다면
				당연히 원래 문서 A의 내용도 영향을 받습니다. 
				</p>
				<p>
				전통적인 해결방식은 수기로 참조관계를 적어두거나 비슷한 내용을
				같은 디렉토리로 묶기 또는 머리로 기억하기 정도입니다. 그러나
				이런 방법으로는 기획 내용의 변화가 가져오는 영향을 명확하게
				파악할 수 없습니다. 이를 해결하기 위해서 Gesign은 참조 파일
				추적을 활용합니다. 
				</p>
				<p>
				참조 파일 추적의 논리는 매우 간단합니다. 모든 기획 문서는
				자신이 참조하는 문서(이후 레퍼런스로 지칭)들이 있습니다. 어떤
				레퍼런스 파일이 변경된다면 그것을 참조하고 있는 모든 문서들이
				점검이 필요한 상태(Outdated)로 표시됩니다. 그러므로 기획자는
				영향을 받는 기획이 무엇인지를 한눈에 파악하고 수정할 수
				있습니다. 참조 파일은 매우 복잡하게 중첩될 수 있으며 레퍼런스가
				무한히 순환하는 지를 검사하기 때문에 사용자인 기획자는 외부
				상황을 걱정할 필요 없이 순수하게 기획의 내용에만 집중할 수 있게
				됩니다.
				</p>
				<br>
				<figure id="gesign_logic">
					<img style="width:50%; display:block; margin: auto;" src="./img/gesign_flow_kr.png" alt="Gesign flow"/>
					<br>
					<figcaption>Gesign의 추적 논리.</figcaption>
				</figure>
				<h4 id="gdmarp"><strong>Rif, 파일 추적 CLI 프로그램</strong></h4>
				<a href="https://github.com/simhyeon/rif" target="_blank">Github 링크</a>
				<figure id="rif_demo">
					<img src="./img/rif_demo.png" alt="Rif demo image"/>
					<figcaption>Rif 데모: 파일들의 관계들 그리고 상태를 확인할 수 있다.</figcaption>
				</figure>
				<br>
				<p>
				Rif는 Gesign의 한계를 극복하기 위해서 만들어진 커맨드 라인
				인터페이스 프로그램으로서 텍스트 에디터, 그리고 파일 타입과
				무관하게 사용하면서 기존의 다양한 워크플로우에 역동적으로
				결합될 수 있도록 하는 프로그램입니다. 
				</p>
				<p>
				Gesign은 Electron 기반 프로그램으로서 다른 텍스트 에디터와는
				결합하여 사용할 수 가 없습니다. 하지만 Rif는 모든 텍스트
				에디터와 연계하여 사용할 수 있으며 파일의 시스템 타임스탬프
				정보와 함께 rif.json 이라는 JSON 통해서 파일 관계를 추적하기
				때문에 모든 종류의 파일을, 즉 docx나 pptx 같은 XML 기반 파일을
				포함하여 Binary파일 또한 추적이 가능합니다.
				</p>
				<p>
				Rif의 파일 추적 논리는 Gesign과 완전히 동일하며, 그래픽 유저
				인터페이스라는 의존성에 벗어나서 커맨드 라인 기반으로 변형한
				것입니다. 
				</p>
				<h4 id="gdmarp"><strong>Gdmarp 자동화 스크립트</strong></h4>
				<a href="https://github.com/simhyeon/gdmarp" target="_blank">Github 링크</a>
				<figure id="gdmarp_demo">
					<img src="./img/gdmarp_demo.png" alt="Gdmarp demo image"/>
					<figcaption>Gdmarp 데모: 좌측의 텍스트 파일이 우측의 슬라이드로 변환된다.</figcaption>
				</figure>
				<br>
				<p>
				Gdmarp란 <strong>GDT(Game document text) 파일을 html, pdf,
				pptx, wikitext, webui로 변환</strong>해 주는 자동화
				스크립트입니다. Gdmarp는 여러 유닉스(Unix) 텍스트 변환
				프로그램을 결합하여 매우 간단한 텍스트 파일에서 복합적인 파일을
				자동으로 생성합니다. 
				</p>
				<p>
				Gdmarp의 핵심 철학은 <strong>문서의 동적 생성</strong>에
				있습니다. Gdmarp는 다음과 같은 기능을 제공합니다. 
				</p>
				<ul>
					<li>
						문서는 <strong>한 번만 작성</strong>해도 다양한
						포맷으로 출력 가능합니다.  Gdmarp에서 사용하는 매크로는
						출력되는 포맷마다 각각 정의되어 있기 때문에 하나의
						문서에서 동일한 내용의 파워포인트와 위키 페이지가
						출력됩니다. 
					</li>
					<li>
						<strong>변수 사용</strong> - 매크로 변수를 사용하여
						동일한 문서의 여러 부분에서 다양한 문서에서 하나의
						변수를 사용할 수 있습니다. 변수의 내용이 바뀌면 모든
						문서의 내용이 변경됩니다.
					</li>
					<li>
						<strong>SQL 쿼리</strong> - 엑셀 등에서 데이터 정보를
						csv 파일 형태로 저장한 뒤 csv를 SQLITE 데이터베이스에
						올려 다양한 쿼리문을 통해서 표를 출력할 수 있습니다.  
					</li>
					<li>
						<strong>파일 재사용</strong> - 문서 동일성을 확보하기
						위한 문서 형식 정보나, 반복되는 내용들을 마크다운
						파일로 저장하여 매크로 한 줄로 불러올 수 있습니다. 
					</li>
				</ul>
				<p>
				그리고 Gdmarp은 M4라는 매크로를 사용하여 셸(Shell)과 직접
				상호작용하기 때문에 그 가능성은 무궁무진하다고 할 수 있습니다. 
				</p>
				<p>
				Gdmarp를 사용하면 디자이너는 어떤 부분에 어떤 숫자를 썼는지를
				고민할 필요가 없고 팀 요구사항에 맞는 형식에 맞추기 위해서
				반복작업을 할 필요도 없습니다. Sql 쿼리를 사용하여 테이블을
				만들게 될 경우에는 원본 데이터베이스가 바뀌어도 다시 테이블을
				수정하지 않아도 자동으로 내용이 변경됩니다.
				</p>
				<p>
				Gdmarp의 또다른 특장점은 <strong>여러 형식으로 출력</strong>할
				수 있다는 것입니다. Html로 변환해서 로컬 인트라넷 서버에 올려
				모든 팀이 볼 수 있도록 하거나, pdf로 변환하여 동적 성질을 다소
				희생하는 한편 사용성을 높일 수도 있습니다. 혹은 산업 표준인
				PPTX로 출력할 수 도 있습니다. 
				</p>
				<p>
				또한 wikitext로 출력하고 자동으로 mediawiki 링크로 Post할 수도
				있습니다. webui 매크로를 사용하면 UI/UX 데모를 위한 단일 html
				페이지로 출력할 수도 있습니다.
				</p>
				<br>
				<figure id="gdmarp_flow">
					<img style="width:50%; display:block; margin: auto;" src="./img/gdmarp_flow_kr.png" alt="Gesign flow"/>
					<br>
					<figcaption>Gdmarp의 작동 방식</figcaption>
				</figure>

				<!-- Separator -->

				<br>
				<h2 id="gameDevelopment">게임 개발</h2>
				<hr/>
				<p>
				시스템 디자이너는 게임이 어떻게 작동하는 지를 알아야 합니다.
				어떤 기획이 성공할 수 있는 것인지를 연구하는 것은 불가능하지
				않지만 <strong>어떤 기획을 구현하는 일은 불가능</strong>할 수
				있습니다. 그러므로 시스템 디자이너가 어떤 기획이 <strong>실현
				가능한 일인지를 구분</strong>할 수 있어야 게임 개발이 효율성이
				올라갑니다. 
				</p>
				<p>
				저는 게임의 작동원리를 알기 위해서 여러가지를 도전하며 공부했습니다. 
				</p>
				<br/>
				<h4 id="unityCardGame"><strong>유니티 게임, 리들러: 온라인 카드 게임</strong></h4>
				<a href="https://www.youtube.com/watch?v=AcXMi3vbil4&t=156s" target="_blank">게임 설명 영상</a>
				<figure id="cardGameDemo">
					<img src="./img/card_game_riddler.png" alt="Card game demo"/>
					<figcaption>Unity와 내장된 네트워크 모듈인 Unet으로 개발한 카드 게임</figcaption>
				</figure>
				<br>
				<p>
				리들러는 Heroes of Might and Magic VII라는 상용 게임 리소스를
				사용하여 만든 팬 게임입니다. 
				</p>
				<p>
				리들러는 카드를 조합해서 기술을 발동하고 상대에게 대미지를 주어
				체력을 0으로 만들면 승리하는 게임입니다. 다른 카드 게임과의
				차이점은 리들러는 자신의 손에 있는 카드패와 모두에게 공개된
				카드패인, 커뮤니티 카드를 조합하여 스킬을 발동한다는 점입니다.
				그러므로 플레이어들은 상대가 어떤 스킬을 착용했는지 그리고,
				현재 모두에게 공개되어 있는 커뮤니티 카드를 기반으로 상대의
				조합을 예측해서 상대의 대미지를 카운터 치거나 방어하여 대미지를
				줄일 수 있습니다. 
				</p>
				<p>
				여기에 더해서 플레이어는 베팅을 통해서 현재 자기가 발동할 카드
				조합 기술의 효과를 강화할 수 있습니다. 이를 통해서 상대
				플레이어는 베팅을 한 플레이어가 강력한 스킬을 사용하려는 것을
				예측할 수 있고 반면 플레이어는 베팅을 많이 걸어 블러핑을 하고
				상대로 하여금 방어적인 기술을 사용하도록 유도할 수도 있습니다. 
				</p>
				<p>
				처음으로 유니티를 사용해서 만든 리들러를 통해서 C#의 문법,
				Unet을 통해서 간단한 P2P 네트워크의 원리, 기본적인
				Monomorphism을 공부할 수 있었습니다. 
				</p>
				<br/>
				<h4 id="tetrisGame"><strong>테트리스 게임, 데이터 지향 프로그래밍</strong></h4>
				<a href="https://github.com/simhyeon/tetrisgame" target="_blank">Github 링크</a>
				<figure id="tetrisDemo">
					<img style="width: 50%; display:block; margin: auto;"src="./img/tetris_demo.png" alt="Tetris demo"/>
					<figcaption>Rust 프로그래밍 언어와 Amethyst 데이터 지향 게임 엔진으로 개발한 테트리스 게임</figcaption>
				</figure>
				<br>
				<p>
				테트리스 게임(원제: TetrisGame)은 유명한 고전 게임 테트리스를
				Rust 라는 프로그래밍 언어와 Amethyst라는 데이터 지향 프로그래밍
				기반의 게임 엔진으로 개발한 게임입니다. 
				</p>
				<p>
				<strong>Rust</strong> 라는 프로그래밍 언어를 선택한 것은 Rust가
				현재 존재하는 <strong>게임 프로그래밍의 난관을 대부분
				해결</strong>해 주는 차세대 언어이기 때문입니다. 레거시 언어인
				C++를 익히는 것도 중요하지만 앞으로 사용하게 될 언어를 미리 배우는
				것도 필요하다고 판단했고 역시 차세대 프로그래밍 패러다임인
				<strong>데이터 지향 프로그래밍</strong>과 함께 공부하기 위해서
				테트리스 게임 프로젝트를 시작했습니다. 
				</p>
				<hr style="width: 50%;">
				<p>
				Rust의 특징들을 간단하게 요약하면 다음과 같습니다. 
				<ul>
					<li>C++ 만큼 빠른 속도</li>
					<li>메모리 오류가 발생하지 않음(dangling pointer, double free 등)</li>
					<li>데이터 레이스(data race)가 발생하지 않음.</li>
				</ul>
				</p>
				<p>
				그러므로 Rust로 게임을 개발할 경우 기존의 <strong>게임 성능을
				잃지 않으면서</strong>, 대부분의 런타임 오류가 없어지기
				때문에 게임 <strong>개발 기간의 예측 가능성이 급격히
				상승</strong>합니다. 또한 데이터 레이스가 발생하지 않기
				때문에 멀티 코어 활용도가 올라가고 특히나 코어 개수가 많은
				<strong>모바일 환경에서 성능을 확보</strong>하기 쉬워집니다. 
				</p>
				<p>
				데이터 지향 프로그래밍의 특징은 다음과 같습니다. 
				<ul>
					<li>캐시 미스가 최소화되어 SIMD 명령어에 최적화</li>
					<li>모든 시스템이 모듈화되어 의존관계에서 탈피함</li>
				</ul>
				</p>
				<p>
				데이터 지향 프로그래밍으로 게임을 개발하면 모든 시스템 로직은
				원칙적으로 <strong>병렬적으로 처리</strong>됩니다. 또한
				시스템이 완전히 모듈화되어 서로 상관하지 않기 때문에 시스템
				간의 상호작용은 마치 그래픽스 파이프라인처럼 정보를 전달하게
				됩니다. 이 방법의 장점은 게임의 기능과 시스템이 일대일로
				대응되기 때문에 게임에서 문제가 발생할 경우 <strong>문제 부분을
				그 즉시 파악 가능</strong>하다는 것입니다. 
				</p>
				<hr style="width: 50%;">
				<p>
				실제로 게임을 개발하면서 단 한번도 메모리 오류가 발생하지
				않았고 런타임 오류는 테트리스 블록에 적용할 텍스쳐 경로가
				잘못된 사례 정도였습니다. 
				</p>
				<p>
				게임은 데이터 지향 디자인에 따라 다음과 같이 설계되었습니다. 
				</p>
				<figure id="tetrisLogic">
					<img style="width: 80%; display:block; margin: auto;"src="./img/tetris_flow_kr.png" alt="Tetris demo"/>
					<figcaption>테트리스 게임의 기본적인 로직 구조</figcaption>
				</figure>
				<br>
				<p>
				블록을 스폰하고 블록에 중력을 적용하고 키 입력을 받아 블록을
				움직이는 시스템은 모두 병렬적으로 작동합니다. 그리고 물리
				시스템, 적층(스택) 붕괴 시스템은 순서대로 진행합니다. 
				</p>
				<p>
				데이터 지향 디자인에 특유한 특징으로서 모든 시스템은 서로
				구분되어 있습니다. 그러므로 당연히 블록 중력 시스템과 키 입력
				시스템 또한 물리 법칙에 상관하지 않습니다. 블록 중력 시스템과
				키 입력 시스템은 블록이 어떤 식으로 움직여야 하는가를
				큐(queue)의 형태로 물리 시스템에 전달합니다(piping). 모든 물리
				법칙의 적용과 상호작용은 단 하나의 시스템 그리고 오로지 하나의
				시스템인 물리 시스템에서만 적용되며 다른 어떤 시스템도 간섭할
				수 없습니다. 그 결과 게임에서 물리에 문제가 있을 때마다
				<strong>물리 시스템을 중심으로 점검하면 모든 문제가
				해결</strong>됐습니다. 
				</p>
				<p>
				Rust와 데이터 지향 시스템은 쉽지 않습니다. 하지만 그 핵심
				개념을 이해하고 나니 C++나 다른 업계 표준 언어, 사실상의 표준인
				객체 지향 프로그래밍에 비해서도 어려울 게 없습니다. 모든 게임
				개발을 당장 차세대 언어나 방법론으로 바꿔야 하는 것은 아닙니다.
				하지만 그 때가 와도 문제가 없도록 저는 준비되었습니다. 
				</p>
				<p>
				이 테트리스 게임은 Unity로 포팅되어 구글 플레이 스토어에 등록하기도 했습니다. 
				</p>
				<a href="https://play.google.com/store/apps/details?id=com.DefaultCompany.Tetris" target="_blank">구글 플레이 블록 게임</a>
				<br><br>
				<h4 id="gameServer"><strong>게임 서버 개발</strong></h4>
				<a href="https://github.com/simhyeon/cardserver" target="_blank">Github 링크</a>
				<br>
				<a href="https://www.youtube.com/watch?v=eTygwHH1sW4&t=125s" target="_blank">데모 영상</a>
				<br><br>
				<figure id="cardserver_demo">
					<img src="./img/card_game_server.png" alt="Game server demo image"/>
					<figcaption>게임 서버 데모: 방 ID를 키로 사용하는 서버</figcaption>
				</figure>
				<br>
				<p>
				게임 "Card game"은 게임 서버를 직접 공부하면서 제작하기 위한
				프로젝트입니다. 처음 유니티를 공부하면서 사용했던 unet은 높은
				레벨의 모듈이었기 때문에 정확히 게임 서버가 어떻게 유저간
				정보를 교환하고 연산을 처리하는 지를 알 수 없었기 때문에 직접
				만들어 보기로 했습니다. 
				</p>
				<p>
				직접 제작한 서버는 P2P가 아닌 소위 dedicated 서버의 구조로
				제작되었습니다. 클라이언트와 서버는 웹소켓 프로토콜로 서로
				통신하며 서버는 해시 알고리즘으로 생성된 RoomId를 통해서 방들을
				관리하고 역시나 같은 방법으로 생성된 PlayerId를 통해서 게임에
				참여하는 2명의 메시지를 처리하도록 설계했습니다. 좀 더 제대로된
				프로젝트를 진행한다고 한다면 redis와 같은 규모 있는
				라이브러리를 사용했겠지만 프로젝트의 규모를 고려하여 일반적인
				해시맵으로 구현했습니다. 
				</p>
				<p>
				클라이언트가 전송한 내용은 Json 포맷으로 파싱되어 해석됩니다.
				서버는 해당 메시지의 내용을 분석하고 클라이언트에 변화가
				필요하다고 변화해야 하는 내용을 담은 내용을 다시 Json 포맷으로
				감싸 클라이언트 일방, 또는 모든 클라이언트에게 전송합니다. 이
				때 전송은 transmission과 reception이라는 인터페이스에 의해서
				변환되는 바이트 스트림의 형태로 구성됐기 때문에 한 쌍의
				인터페이스 만으로는 양뱡향 통신이 불가능했고 한 연결마다 한
				쌍의 인터페이스를 더 생성해서 바이트 스트림을 리다이렉트 하는
				형식으로 양방향 통신을 구현했습니다. 
				</p>
				<br>
				<figure id="cardserver_txrx">
					<img style="width: 70%; display:block; margin:auto;" src="./img/cardserver_txrx.png" alt="Game server txrx image"/>
					<br>
					<figcaption>서버의 통신 인터페이스 구조</figcaption>
				</figure>
				<br>
			</div>	
		</div>	
	</body>
</html>
